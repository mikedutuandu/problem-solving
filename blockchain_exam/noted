1. Demo practice run it by https://remix.ethereum.org/

2. Demo practice run it by hardhat

3. Flow sign a signature and verify it: https://solidity-by-example.org/signature/
### Creating sigHash and Signature (Frontend/Off-chain):

/ 1. Create the same hash that contract will create
const messageHash = ethers.utils.solidityKeccak256(
    ['address', 'uint256'],
    [userAddress, amount]
);

// 2. Sign this hash with private key - this creates a unique signature
const signature = await signer.signMessage(ethers.utils.arrayify(messageHash));


### Verifying in Contract (On-chain):
function withdraw(uint256 amount, bytes calldata signature) {
    // 1. Recreate the same hash
    bytes32 sigHash = keccak256(abi.encodePacked(msg.sender, amount));

    // 2. Verify signature - this recovers the signer's address from signature
    address recoveredSigner = ecrecover(sigHash, v, r, s);

    // 3. Check if recovered signer is the owner
    require(recoveredSigner == owner(), "Invalid signature");
}
The key points:

We're not comparing hash with signature
The signature is used to recover who signed the message
We verify if the recovered signer is the owner
ecrecover gets the address that created the signature

It's like:

Owner signs a message (creates signature)
Contract uses that signature to figure out who signed
Checks if that signer is the owner